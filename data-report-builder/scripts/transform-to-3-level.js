const fs = require('fs');
const path = require('path');

// Path to the current 4-level taxonomy
const oldTaxonomyPath = path.join(__dirname, '../src/data/templateTaxonomy.ts');
const newTaxonomyPath = path.join(__dirname, '../src/data/templateTaxonomy.ts');

// Read the old taxonomy file
const oldTaxonomyContent = fs.readFileSync(oldTaxonomyPath, 'utf8');

// Extract the JSON part from the .ts file
const jsonMatch = oldTaxonomyContent.match(/export const TEMPLATE_TAXONOMY: TemplateCategory\[\] = (\s*\[[\s\S]*?\]\s*);/);
if (!jsonMatch || !jsonMatch[1]) {
  console.error('Could not extract JSON from taxonomy file.');
  process.exit(1);
}
const oldCategories = JSON.parse(jsonMatch[1]);
console.log('ðŸ“– Parsed old 4-level taxonomy:', oldCategories.length, 'categories');

// Transform from 4-level to 3-level
// Category â†’ Topic â†’ SubTopic â†’ Reports
// becomes
// Category â†’ Topic â†’ Reports (SubTopics become Topics, and their reports stay as reports)
function transformToThreeLevel(categories) {
  let totalTopics = 0;
  let totalReports = 0;

  const transformed = categories.map(category => ({
    id: category.id,
    label: category.label,
    description: category.description,
    topics: category.topics.flatMap(oldTopic => {
      // Each SubTopic in the old structure becomes a Topic in the new structure
      return oldTopic.subTopics.map(subTopic => {
        totalTopics++;
        totalReports += subTopic.reports.length;
        return {
          id: subTopic.id, // SubTopic ID becomes Topic ID
          label: subTopic.label, // SubTopic label becomes Topic label
          description: subTopic.description,
          reports: subTopic.reports, // Reports stay as-is
        };
      });
    }),
  }));

  return { transformed, totalTopics, totalReports };
}

const { transformed, totalTopics, totalReports } = transformToThreeLevel(oldCategories);

// Generate the TypeScript content for the new taxonomy file
const tsContent = `// This file is auto-generated by scripts/transform-to-3-level.js
// Do not edit this file directly.

// Template taxonomy for waterfall category filtering
// Defines the hierarchical structure: Category â†’ Topic â†’ Reports (shown in carousel)

// Base table definition for SQL generation
export interface BaseTable {
  alias: string;
  table: string;
  join_on?: string;
  join_type?: 'left' | 'right' | 'inner';
}

// Metric definition
export interface ReportMetric {
  id: string;
  label: string;
  expression: string;
  type: 'integer' | 'currency' | 'ratio' | 'float';
  note?: string;
}

// Dimension definition for grouping
export interface ReportDimension {
  id: string;
  label: string;
  column: string | null;
  table: string | null;
  expression?: string;
}

// Filter definition
export interface ReportFilter {
  id: string;
  label: string;
  type: 'daterange' | 'enum' | 'string' | 'country' | 'number' | 'date' | 'boolean';
  column: string;
  operator: 'between' | 'in' | '=' | '>=' | '<=' | '>' | '<';
  param?: string;
  param_from?: string;
  param_to?: string;
  default_value?: string;
}

// Order by definition
export interface ReportOrderBy {
  expression: string;
  direction: 'asc' | 'desc';
}

// Complete report template (represents a single template shown in carousel)
export interface TemplateReport {
  id: string;
  label: string;
  description: string;
  base_tables: BaseTable[];
  time_column: string;
  metrics: ReportMetric[];
  dimensions: ReportDimension[];
  default_dimension: string | null;
  required_filters: ReportFilter[];
  optional_filters: ReportFilter[];
  default_order_by?: ReportOrderBy[];
}

// Topic groups related reports (e.g., "Acceptance overview")
export interface TemplateTopic {
  id: string;
  label: string;
  description: string;
  reports: TemplateReport[];
}

// Top-level category (e.g., "Payments")
export interface TemplateCategory {
  id: string;
  label: string;
  description: string;
  topics: TemplateTopic[];
}

// Full taxonomy structure
export const TEMPLATE_TAXONOMY: TemplateCategory[] = ${JSON.stringify(transformed, null, 2)};
`;

fs.writeFileSync(newTaxonomyPath, tsContent, 'utf8');
const fileSize = fs.statSync(newTaxonomyPath).size / 1024; // in KB

console.log('âœ… Transformed to 3-level hierarchy');
console.log('   Categories:', transformed.length);
console.log('   Topics:', totalTopics);
console.log('   Reports:', totalReports);
console.log('ðŸ“ Written to:', newTaxonomyPath);
console.log('   File size:', fileSize.toFixed(2), 'KB');

